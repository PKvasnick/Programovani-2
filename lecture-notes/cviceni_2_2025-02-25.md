



## Programování 2

# 2. cvičení, 25-2-2025



## Farní oznamy

1. Tento text a kódy ke cvičení najdete v repozitáří cvičení na https://github.com/PKvasnick/Programovani-2.
2. **Domácí úkoly**: 
   - Na první várku domácích úkolů přišlo docela dost řešení 
   - Byly to méně snadné úkoly
   - Nakonec jsme povětšinou dokonvergovali k rozumným řešením.
   - O nejčastějších problémech promluvíme podrobněji


---

**Obsah**:

- Kvíz
- Domácí úkoly:
  - Načítání posloupností

  - Kdy lze posloupnost zpracovat průběžně a jak to udělat?

- Resty z minula: sečítání čísel po číslicích


---

## Na zahřátí

> Pokud to funguje, nedotýkej se toho.

<img src="img\nechytej_co_funguje.jpg" alt="nechytej_co_funguje" style="zoom:33%;" />

Dobrá, nebo špatná rada?

- nepromyšlené zásahy do kódu mohou mít nečekané důsledky
- to neznamená, že bychom se neměli snažit vylepšit ošklivý kód nebo doplnit nové funkce.

---

### Co dělá tento kód

```python
jmena = {"Jana", "Pavel", "Pepa", "Franta"}
dalsi = {"Eva", "Pepa", "Katka", "Standa"}
jmena & dalsi 
????
jmena and dalsi
jmena - dalsi
```

### Seřaďte podle data narození

```python
lide = [
    ("Jana", "Nováková", 1964),
    ("Kateřina", "Kocourová", 1962),
    ("Jozef", "Winkler", 1952),
    ("Petr", "Suchý", 1968),
    ("Jan", "Michal", 1951)
]
```

- `operator.itemgetter`
- lambda


---

## Domácí úkoly

### 1. Načtení posloupnosti z konzole a její zpracování

Toto děláte u domácích úkolů běžně:

> Vstupní posloupnost načtete z konzoly číslo po čísel, každé číslo na novém řádku. Posloupnost je ukončená řádkou s −1, která nepatří do posloupnosti. 

#### Generická verze:

```python
def read_from_console() -> list[float]:
    a = []
    while True:
        line = input()
        if "-1" in line:
            break
        a.append(float(line))
	return a
```

Poznámky:

1. Kód `-> list[float]` oznamuje Pythonu, že výstupem funkce je seznam desetinných čísel. Podobně můžeme oznámit i typy parametrů, a analyzátor kódu ve vašem IDE pak zahlásí chybu, pokud někde použijeme nesprávný typ.
2. Logika: Máme nekonečný cyklus a vyskakujeme z něj, pokud narazíme na znak konce posloupnosti. 
3. Testujeme `"-1" in line` namísto `line == "-1"` Proč? (Už vás někdy ReCodEx trýznil hláškami "End-of-file error" u testů?)

Ze souboru:

```python
def read_from_file(filename: str) -> list[float]:
    a = []
    with open(filename, "r") as infile:
        for lines in infile:
            if "-1" in line:
                break
            a.append(float(line))
    return a 
```

#### Načíst do paměti nebo nenačíst?

U některých úkolů dokážeme čísla zpracovávat postupně a nepotřebujeme mít celou posloupnost uloženou v paměti. 

**Příklad:** : nalezení maximální hodnoty, výpočet průměru a standardní odchylky

V těchto případech má algoritmus formu propagování nějakého vnitřního stavu přes vstupná data:  Začneme počátečním stavem (např. nejmenší možnou hodnotou typu `float`, tedy `float('-inf')`) a jak přicházejí data, aktualizujeme ji (např. se u každé vstupní hodnoty ptáme: Je toto největší hodnota, jakou jsem doposud viděl? a pokud je, nastavíme vnitřní stav na tuto hodnotu).  Na konci máme výsledný stav (například maximální hodnotu posloupnosti) a umíme dokázat, jaké má vlastnosti (například že je to opravdu maximum posloupnosti).

Příklady:

- maximum
- k-tý největší prvek
- střední hodnota a standardní odchylka

Naopak, u jiných úloh potřebujeme mít posloupnost v paměti celou nebo její podstatnou část

Příklady: 

- medián
- dělící bod posloupnosti

#### Načítání pomocí generátoru

Pokud chceme hledat například maximum posloupnosti a nechceme ji celou načítat, musíme kód pro načítání a hledání promíchat. To je nešťastné, pokud chceme pro zpracování posloupnosti použít stejný kód pro načítání ze standardního vstupu nebo souboru. 

```python
m = float("-inf")
while "-1" not in (line := input()):
    number = float(line)
    if number > m:
        m = number
        
```

Poznámky:

- Inicializace: `float("-inf")` je nejmenší číslo v plovoucí desetinné čárce. Jaké je nejmenší celé číslo?
- `:=` je “walrus”, čili mroží operátor, pomocí kterého můžeme ukrást hodnotu, kterou načte `input()` do proměnné `line`. To je šikovné a řeší to malý problém s logikou načítacího cyklu: protože v cyklu načítáme, musíme kód zpřeházet, pokud chceme testovat v hlavičce `while` anebo testovat uvnitř cyklu a použít `break`

```python
def read_from_console():
    while "-1" not in (line := input()):
        yield float(line)
    return

m = float("-inf")
for number in read_from_console():
    if number > m:
        m = number
print(m)
```

Napište kód, který takto nalezne maximum při načítání posloupnosti ze souboru. 

#### Reduce

Uměli bychom uzavřít otevřený cyklus `while`, resp. `for`, který máme v tomto kódu?

Můžeme použít funkci `functools.reduce`, která dělá přibližně toto:

```python
def reduce(function, iterable, initializer=None):
    it = iter(iterable)
    if initializer is None:
        value = next(it)
    else:
        value = initializer
    for element in it:
        value = function(value, element)
    return value
```

Tedy funkce `reduce` propaguje a aktualizuje nějaký stav přes posloupnost. 

```python
from functools import reduce

def read_from_console():
    while "-1" not in (line := input()):
        yield float(line)
    return

maximum = reduce(max, read_from_console, float("-inf"))
print(maximum)
```

Takovýto kód bude rychlý, protože cyklus se vykonává uvnitř funkce, a tedy běží v C a ne v Pythonu.

####  Podobné úlohy

- rozhodnout, zda je posloupnost čísel monotonní a jak (konstantní, rostoucí, neklesající, klesající, nerostoucí) 
- v posloupnosti čísel nalézt druhou největší hodnotu a počet jejích výskytů
- v posloupnosti čísel určit délku nejdelšího souvislého rostoucího úseku
- v posloupnosti čísel určit počet různých hodnot
- v posloupnosti čísel nalézt souvislý úsek se součtem K (pro zadanou hodnotu K)
- v posloupnosti kladných čísel nalézt souvislý úsek se součtem K (pro zadanou hodnotu K)
- v posloupnosti čísel nalézt souvislý úsek s maximálním součtem.



---

## Z minula

**Součet dvou čísel**

Na vstupu načteme dvě celá čísla jako znakové řetězce. Na výstupu má váš kód vypsat jejich součet, ale máte povolenou sečítat pouze číslice 0-9, ne celá čísla. Můžete si představit, že pro sčítání máte k dispozici tabulku typu

|         | **0**  | **1**  | **...** | **8**  | **9**  |
| ------- | ------ | ------ | ------- | ------ | ------ |
| **0**   | (0, 0) |        |         |        |        |
| **1**   | (1, 0) | (2, 0) |         |        |        |
| **2**   | (2, 0) | (3, 0) |         |        |        |
| **...** |        |        |         |        |        |
| **8**   | (8, 0) | (9, 0) |         | (6, 1) |        |
| **9**   | (9, 0) | (0, 1) |         | (7, 1) | (8, 1) |

kde první číslo jsou jednotky součtu a druhé číslo je "přenos". 

**Poznámky**

* Jak to naprogramovat, aby kód byl hezký a rozumně efektivní? ("uzavřené" cykly: namísto `for` a `while`  atd.)

- Funkce `zip` a funkce `itertools.zip_longest`
- Oplatí se pro takováto čísla (uspořádané seznamy číslic) zavést třídu?
- Samozřejmě budeme chtít také odečítat, násobit a dělit. Umíme vytvořit nějaký sjednocující algoritmus?

---

Zkusíme jednoduché věci:

1. Načtení čísla

```python
digits = [int(c) for c in input()]
```

2. Dvojice číslic pozpátku:

```python
from itertools import zip_longest
```

![image-20240220143215373](image/zip_longest.png)

```python
zip_longest(get_digits_reversed(digits1), get_digits_reversed(digits2),0)
```

**Alternativa**: protože výsledek může být o číslici delší než nejdelší z čísel, můžeme také čísla předem doplnit nulami na potřebnou délku a použít obyčejný `zip`:

```python
delka = max(len(a0), len(b0)) + 1
a0 = a0.zfill(delka)
b0 = b0.zfill(delka)
```

Pozor, toto funguje pro znakové řetězce, ne pro seznamy číslic. 

4. Sečítání s přechodem:

```python
def add_and_carry(d1:int, d2:int) -> {int, int}:
    return divmod(d1+d2,10)
```

Na výstupu budeme mít dvojici (přechod, součet). Jak ale budeme takovéto dvojice sečítat v cyklu? 

```python
from itertools import accumulate
```

![image-20240220150121158](image/accumulate.png)

Funkce `accumulate` bude postupně zpracovávat dvě dvojice číslic a z nich vytvoří novou dvojici. Jak to uděláme?

5. Teď už je lehké dát všechno dohromady:

```python
from itertools import zip_longest

def get_digits_reversed(digits):
	yield from reversed(digits)

def add_and_carry(d1:int, d2:int) -> {int, int}:
    return divmod(d1+d2,10)

digits1 = [int(c) for c in input()]
digits1 = [int(c) for c in input()]

def digit_by_digit_add(digits1: list[int], digits2: list[int]) -> 

```

A co kdybychom si namísto počítání vytvořili tabulku a jenom z ní odčítali součty a přenosy?

